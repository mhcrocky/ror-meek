function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import PropTypes from 'prop-types';
import React from 'react';
import warning from 'warning';
import memoize from 'memoize-one';
import elementType from 'prop-types-extra/lib/elementType';
import createEventHandler from './utils/createEventHandler';
import { filterAndMapErrors } from './utils/ErrorUtils';
import { withState, FORM_DATA, FormActionsContext } from './Contexts';
/**
 * A Form submit button, for triggering validations for the entire form or specific fields.
 */

var FormSubmit =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(FormSubmit, _React$Component);

  function FormSubmit() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.eventHandlers = {};
    _this.getEventHandlers = createEventHandler(function (event) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this.props[event] && _this.props[event](args);

        _this.handleSubmit();
      };
    });
    _this.memoFilterAndMapErrors = memoize(filterAndMapErrors, function (_ref, _ref2) {
      var a = _ref[0];
      var b = _ref2[0];
      return a.errors === b.errors && a.names === b.names && a.maperrors === b.maperrors;
    });
    return _this;
  }

  var _proto = FormSubmit.prototype;

  _proto.handleSubmit = function handleSubmit(event, args) {
    var _this$props = this.props,
        actions = _this$props.actions,
        triggers = _this$props.triggers;

    if (!actions) {
      return process.env.NODE_ENV !== "production" ? warning(false, 'A Form submit event ' + 'was triggered from a component outside the context of a Form. ' + 'The Button should be wrapped in a Form component') : void 0;
    }

    if (triggers && triggers.length) actions.onValidate(triggers, event, args);else actions.onSubmit();
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        events = _this$props2.events,
        triggers = _this$props2.triggers,
        children = _this$props2.children,
        errors = _this$props2.errors,
        submits = _this$props2.submits,
        Component = _this$props2.as,
        _1 = _this$props2.actions,
        props = _objectWithoutPropertiesLoose(_this$props2, ["events", "triggers", "children", "errors", "submits", "as", "actions"]);

    var partial = triggers && triggers.length;

    if (partial) {
      errors = this.memoFilterAndMapErrors({
        errors: errors,
        names: triggers
      });
    }

    props = _extends(props, this.getEventHandlers(events));
    return typeof children === 'function' ? children(_extends({
      errors: errors,
      props: props
    }, submits)) : React.createElement(Component, _extends({
      type: partial ? 'button' : 'submit'
    }, props), children);
  };

  return FormSubmit;
}(React.Component);

FormSubmit.propTypes = {
  /**
   * The `<button/>` type
   */
  type: PropTypes.oneOf(['button', 'submit']),

  /**
   * Specify particular fields to validate in the related form. If empty the entire form will be validated.
   */
  triggers: PropTypes.arrayOf(PropTypes.string.isRequired),

  /**
   * Provide a render function to completely override the rendering behavior
   * of FormSubmit (`as` will be ignored). In addition to passing through props some
   * additional form submission metadata is injected to handle loading and disabled behaviors.
   *
   * ```js
   * <Form.Submit>
   *   {({ errors, props, submitting, submitCount, submitAttempts }) =>
   *     <button {...props} disabled={submitCount > 1}>
   *       submitting ? 'Savingâ€¦' : 'Submit'}
   *     </button>
   * </Form.Submit>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Control the rendering of the Form Submit component when not using
   * the render prop form of `children`.
   */
  as: elementType,

  /**
   * A string or array of event names that trigger validation.
   *
   * @default 'onClick'
   */
  events: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),

  /** @private */
  errors: PropTypes.object,

  /** @private */
  actions: PropTypes.object,

  /** @private */
  submits: PropTypes.object
};
FormSubmit.defaultProps = {
  as: 'button',
  events: ['onClick']
};
export default withState(function (ctx, props, ref) {
  return React.createElement(FormActionsContext.Consumer, null, function (actions) {
    return React.createElement(FormSubmit, _extends({}, props, {
      ref: ref,
      actions: actions,
      submits: ctx.submits,
      errors: ctx.errors
    }));
  });
}, FORM_DATA.errors | FORM_DATA.SUBMITS);