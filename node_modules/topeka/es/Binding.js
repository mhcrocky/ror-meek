import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import { Consumer } from './BindingContext';
import createBridge from './createChildBridge';
import StaticContainer from './StaticContainer';

function extractTargetValue(eventOrValue) {
  if (!eventOrValue || !eventOrValue.target) return eventOrValue;
  var _eventOrValue$target = eventOrValue.target,
      type = _eventOrValue$target.type,
      value = _eventOrValue$target.value,
      checked = _eventOrValue$target.checked,
      multiple = _eventOrValue$target.multiple,
      files = _eventOrValue$target.files;
  if (type === 'file') return multiple ? files : files[0];

  if (/number|range/.test(type)) {
    var parsed = parseFloat(value);
    return isNaN(parsed) ? null : parsed;
  }

  return /checkbox|radio/.test(type) ? checked : value;
}
/**
 * Hello
 */


var Binding =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(Binding, _React$PureComponent);

  Binding.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    var propsChanged = prevState && nextProps !== prevState.__lastProps;
    return {
      propsChanged: propsChanged,
      __lastProps: nextProps
    };
  };

  function Binding(props, context) {
    var _this;

    _this = _React$PureComponent.call(this, props, context) || this;

    _this.handleEvent = function (event) {
      var _this$props = _this.props,
          bindTo = _this$props.bindTo,
          _this$props$mapValue = _this$props.mapValue,
          mapValue = _this$props$mapValue === void 0 ? extractTargetValue : _this$props$mapValue;

      if (typeof bindTo === 'string') {
        var _mapValue;

        if (typeof mapValue !== 'object') mapValue = (_mapValue = {}, _mapValue[bindTo] = mapValue, _mapValue);
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (_this.updateBindingValue && mapValue) _this.updateBindingValue(mapValue, args);
    };

    _this.state = {};
    _this.getBridgeProps = createBridge(_this.handleEvent);
    return _this;
  }

  var _proto = Binding.prototype;

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(Consumer, null, function (context) {
      _this2.updateBindingValue = context && context.updateBindingValue;
      var _this2$props = _this2.props,
          changeProp = _this2$props.changeProp,
          valueProp = _this2$props.valueProp,
          children = _this2$props.children,
          bindTo = _this2$props.bindTo;

      var childProps = _this2.getBridgeProps(changeProp);

      var valueChanged = true;

      if (context) {
        var lastValue = _this2._value;
        childProps[valueProp] = _this2._value = context.getValue(bindTo);
        valueChanged = lastValue !== _this2._value;
      }

      var propsChanged = _this2.state.propsChanged;
      return React.createElement(StaticContainer, {
        props: childProps,
        shouldUpdate: propsChanged || valueChanged
      }, children);
    });
  };

  return Binding;
}(React.PureComponent);

Binding.propTypes = {
  /**
   * A callback prop name that the Binding should listen for changes on.
   *
   * ```js
   * <Binding changeProp='onSelect'>
   *   {props => <MyDropDown {...props} />}
   * </Binding>
   * ```
   */
  changeProp: PropTypes.string.isRequired,

  /**
   * A prop name for the Binding to set from the BindingContext.
   *
   * ```js
   * <Binding valueProp='selectedValue'>
   *   {props => <MyDropDown {...props} />}
   * </Binding>
   * ```
   */
  valueProp: PropTypes.string.isRequired,

  /**
   * An field name or accessor function, extracting the Binding value
   * from the overall BindingContext value. If a function, it's called
   * with the form value, and the current Form `getter`.
   *
   * ```js
   * <Binding bindTo='details.name'>
   *   <input />
   * </Binding>
   *
   * <Binding
   *   bindTo={(model, getter) => {
   *     let [first, last] = getter(model, 'details.name').split(' ')
   *     return { first, last }
   *   }}
   * >
   *  {props => <MyDropDown {...props} />}
   * </Binding>
   * ```
   */
  bindTo: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,

  /**
   * Customize how the Binding return value maps to the overall BindingContext `value`.
   * `mapValue` can be a a string property name or a function that returns a
   * value to be set to the `bindTo` field.
   *
   * **note:** the default value will attempt to extract the value from `target.value`
   * so that native inputs will just work as expected.
   *
   * ```js
   * <Binding
   *   bindTo='name'
   *   mapValue={dropdownValue =>
   *     dropdownValue.first + ' ' + dropdownValue.last
   *   }
   * >
   *  {props => <MyDropDown {...props} />}
   * </Binding>
   * ```
   *
   * You can also provide an object hash, mapping paths of the BindingContext `value`
   * to fields in the Binding value using a string field name, or a function accessor.
   *
   * ```js
   * <Binding
   *   bindTo={model => {
   *     let [first, last] = model.name.split(' ')
   *     return { first, last }
   *   }}
   *   mapValue={{
   *    name: dropdownValue =>
   *      dropdownValue.first + ' ' + dropdownValue.last
   *   }}
   * >
   *   {props => <MyDropDown {...props} />}
   * </Binding>
   * ```
   *
   * @type func | string | object
   */
  mapValue: function mapValue(props, propName, componentName) {
    if (typeof props.bindTo === 'function' && typeof props[propName] === 'function') return new Error(propName + " must be an Object or a string, when `bindTo` is a function");

    for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    return PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]).apply(void 0, [props, propName, componentName].concat(args));
  },

  /**
   * A render function that returns a react element and is
   * passed the binding callbacks and value.
   *
   * ```js
   * let Surround = (props) => <div {...props}>{props.children}</div>
   *
   * <Binding>
   * {(props)=>
   *   <Surround>
   *     <input type='text' {...props} />
   *   </Surround>
   * }
   * </Binding>
   * ```
   */
  children: PropTypes.func.isRequired
};
Binding.defaultProps = {
  changeProp: 'onChange',
  valueProp: 'value'
};
export default Binding;