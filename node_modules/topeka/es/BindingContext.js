import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import uncontrollable from 'uncontrollable';
import invariant from 'invariant';
import expr from 'property-expr';
import updateIn from './updateIn';

var defaultSetter = function defaultSetter(path, model, val) {
  return updateIn(model, path, val);
};

function wrapSetter(setter) {
  return function () {
    var result = setter.apply(void 0, arguments);
    !(result && typeof result === 'object') ? process.env.NODE_ENV !== "production" ? invariant(false, '`setter(..)` props must return the form value object after updating a value.') : invariant(false) : void 0;
    return result;
  };
}

var _React$createContext = React.createContext({
  getValue: function getValue() {},
  updateBindingValue: function updateBindingValue() {}
}),
    Provider = _React$createContext.Provider,
    Consumer = _React$createContext.Consumer;

export { Provider, Consumer };

var BindingContext =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(BindingContext, _React$Component);

  BindingContext.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var value = _ref.value,
        getter = _ref.getter;

    if (value === prevState.value && getter === prevState.getter) {
      return null;
    }

    return {
      value: value,
      getter: getter,
      bindingContext: {
        updateBindingValue: prevState.bindingContext.updateBindingValue,
        getValue: function getValue(pathOrAccessor) {
          return typeof pathOrAccessor === 'function' ? pathOrAccessor(value, getter) : getter(pathOrAccessor, value);
        }
      }
    };
  };

  function BindingContext() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.updateBindingValue = function (mapValue, args) {
      var _this$props = _this.props,
          model = _this$props.value,
          updater = _this$props.setter,
          onChange = _this$props.onChange;
      var paths = [];
      if (process.env.NODE_ENV !== 'production') updater = wrapSetter(updater);
      Object.keys(mapValue).forEach(function (key) {
        var field = mapValue[key],
            value;
        if (typeof field === 'function') value = field.apply(void 0, args);else if (field === '.' || field == null || args[0] == null) value = args[0];else {
          value = expr.getter(field, true)(args[0]);
        }
        if (paths.indexOf(key) === -1) paths.push(key);
        model = updater(key, model, value, defaultSetter);
      });
      onChange(model, paths);
    };

    _this.state = {
      bindingContext: {
        updateBindingValue: _this.updateBindingValue
      }
    };
    return _this;
  }

  var _proto = BindingContext.prototype;

  _proto.render = function render() {
    return React.createElement(Provider, {
      value: this.state.bindingContext
    }, this.props.children);
  };

  return BindingContext;
}(React.Component);

BindingContext.propTypes = {
  /**
   * BindingContext value object, can be left uncontrolled;
   * use the `defaultValue` prop to initialize an uncontrolled BindingContext.
   *
   * BindingContext assumes that `value` is immutable so you must provide a _new_ value
   * object to trigger an update. The `<Binding/>` components do this by default.
   */
  value: PropTypes.object,

  /**
   * Callback that is called when the `value` prop changes.
   *
   * ```js
   * function(
   * 	value: object,
   * 	updatedPaths: array<string>
   * )
   * ```
   */
  onChange: PropTypes.func,

  /**
   * A function used to extract value paths from the Context value.
   * `getter` is called with `path` and `value` and should return the value at that path.
   * `getter()` is used when a `<Binding/>` provides a string `accessor`.
   *
   * ```js
   * function(
   *  path: string,
   *  value: any,
   * ) -> object
   * ```
   */
  getter: PropTypes.func,

  /**
   * A value setter function. `setter` is called with `path`, the context `value` and the path `value`.
   * The `setter` must return updated form `value`, which allows you to leave the original value unmutated.
   *
   * ```js
   * function(
   *  path: string,
   *  formValue: object,
   *  pathValue: any
   * ) -> object
   * ```
   */
  setter: PropTypes.func
};
BindingContext.defaultProps = {
  getter: function getter(path, model) {
    return path ? expr.getter(path, true)(model || {}) : model;
  },
  setter: defaultSetter
};
export default uncontrollable(BindingContext, {
  value: 'onChange',
  touched: 'onTouch'
});